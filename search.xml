<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[IntelliJ IDEA For Mac 快捷键]]></title>
      <url>%2F2016%2F12%2F21%2FIntelliJ%20IDEA%20For%20Mac%20%E5%BF%AB%E6%8D%B7%E9%94%AE%20%2F</url>
      <content type="text"><![CDATA[Mac键盘符号和修饰键说明 ⌘ Command ⇧ Shift ⌥ Option ⌃ Control ↩︎ Return/Enter ⌫ Delete ⌦ 向前删除键（Fn+Delete） ↑ 上箭头 ↓ 下箭头 ← 左箭头 → 右箭头 ⇞ Page Up（Fn+↑） ⇟ Page Down（Fn+↓） Home Fn + ← End Fn + → ⇥ 右制表符（Tab键） ⇤ 左制表符（Shift+Tab） ⎋ Escape (Esc) 一、Editing（编辑） Control + Space 基本的代码补全（补全任何类、方法、变量） Control + Shift + Space 智能代码补全（过滤器方法列表和变量的预期类型） Command + Shift + Enter 自动结束代码，行末自动添加分号 Command + P 显示方法的参数信息 Control + J 快速查看文档 Shift + F1 查看外部文档（在某些代码上会触发打开浏览器显示相关文档） Command + 鼠标放在代码上 显示代码简要信息 Command + F1 在错误或警告处显示具体描述信息 Command + N, Control + Enter, Control + N 生成代码（getter、setter、构造函数、hashCode/equals,toString） Control + O 覆盖方法（重写父类方法） Control + I 实现方法（实现接口中的方法） Command + Option + T 包围代码（使用if..else, try..catch, for, synchronized等包围选中的代码） Command + / 注释/取消注释与行注释 Command + Option + / 注释/取消注释与块注释 Option + 方向键上 连续选中代码块 Option + 方向键下 减少当前选中的代码块 Control + Shift + Q 显示上下文信息 Option + Enter 显示意向动作和快速修复代码 Command + Option + L 格式化代码 Control + Option + O 优化import Control + Option + I 自动缩进线 Tab / Shift + Tab 缩进代码 / 反缩进代码 Command + X 剪切当前行或选定的块到剪贴板 Command + C 复制当前行或选定的块到剪贴板 Command + V 从剪贴板粘贴 Command + Shift + V 从最近的缓冲区粘贴 Command + D 复制当前行或选定的块 Command + Delete 删除当前行或选定的块的行 Control + Shift + J 智能的将代码拼接成一行 Command + Enter 智能的拆分拼接的行 Shift + Enter 开始新的一行 Command + Shift + U 大小写切换 Command + Shift + ] / Command + Shift + [ 选择直到代码块结束/开始 Option + Fn + Delete 删除到单词的末尾 Option + Delete 删除到单词的开头 Command + 加号 / Command + 减号 展开 / 折叠代码块 Command + Shift + 加号 展开所以代码块 Command + Shift + 减号 折叠所有代码块 Command + W 关闭活动的编辑器选项卡 二、Search/Replace（查询/替换） Double Shift 查询任何东西 Command + F 文件内查找 Command + G 查找模式下，向下查找 Command + Shift + G 查找模式下，向上查找 Command + R 文件内替换 Command + Shift + F 全局查找（根据路径） Command + Shift + R 全局替换（根据路径） Command + Shift + S 查询结构（Ultimate Edition 版专用，需要在Keymap中设置） Command + Shift + M 替换结构（Ultimate Edition 版专用，需要在Keymap中设置） 三、Usage Search（使用查询） Option + F7 / Command + F7 在文件中查找用法 / 在类中查找用法 Command + Shift + F7 在文件中突出显示的用法 Command + Option + F7 显示用法 四、Compile and Run（编译和运行） Command + F9 编译Project Command + Shift + F9 编译选择的文件、包或模块 Control + Option + R 弹出 Run 的可选择菜单 Control + Option + D 弹出 Debug 的可选择菜单 Control + R 运行 Control + D 调试 Control + Shift + R, Control + Shift + D 从编辑器运行上下文环境配置 五、Debugging（调试） F8 进入下一步，如果当前行断点是一个方法，则不进入当前方法体内 F7 进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中 Shift + F7 智能步入，断点所在行上有多个方法调用，会弹出进入哪个方法 Shift + F8 跳出 Option + F9 运行到光标处，如果光标前有其他断点会进入到该断点 Option + F8 计算表达式（可以更改变量值使其生效） Command + Option + R 恢复程序运行，如果该断点下面代码还有断点则停在下一个断点上 Command + F8 切换断点（若光标当前行有断点则取消断点，没有则加上断点） Command + Shift + F8 查看断点信息 六、Navigation（导航） Command + O 查找类文件 Command + Shift + O 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠/ Command + Option + O 前往指定的变量 / 方法 Control + 方向键左 / Control + 方向键右 左右切换打开的编辑tab页 F12 返回到前一个工具窗口 Esc 从工具窗口进入代码文件窗口 Shift + Esc 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口 Command + Shift + F4 关闭活动run/messages/find/… tab Command + L 在当前文件跳转到某一行的指定处 Command + E 显示最近打开的文件记录列表 Option + 方向键左 / Option + 方向键右 光标跳转到当前单词 / 中文句的左 / 右侧开头位置 Command + Option + 方向键左 / Command + Option + 方向键右 退回 / 前进到上一个操作的地方 Command + Shift + Delete 跳转到最后一个编辑的地方 Option + F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在代码编辑窗口可以选择显示该文件的Finder) Command + B / Command + 鼠标点击 进入光标所在的方法/变量的接口或是定义处 Command + Option + B 跳转到实现处，在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口 Option + Space, Command + Y 快速打开光标所在方法、类的定义 Control + Shift + B 跳转到类型声明处 Command + U 前往当前光标所在方法的父类的方法 / 接口定义 Control + 方向键下 / Control + 方向键上 当前光标跳转到当前文件的前一个/后一个方法名位置 Command + ] / Command + [ 移动光标到当前所在代码的花括号开始/结束位置 Command + F12 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法） Control + H 显示当前类的层次结构 Command + Shift + H 显示方法层次结构 Control + Option + H 显示调用层次结构 F2 / Shift + F2 跳转到下一个/上一个突出错误或警告的位置 F4 / Command + 方向键下 编辑/查看代码源 Option + Home 显示到当前文件的导航条 F3选中文件/文件夹/代码行，添加/取消书签 Option + F3 选中文件/文件夹/代码行，使用助记符添加/取消书签 Control + 0...Control + 9 定位到对应数值的书签位置 Command + F3 显示所有书签 七、Refactoring（重构） F5 复制文件到指定目录 F6 移动文件到指定目录 Command + Delete 在文件上为安全删除文件，弹出确认框 Shift + F6 重命名文件 Command + F6 更改签名 Command + Option + N 一致性 Command + Option + M 将选中的代码提取为方法 Command + Option + V 提取变量 Command + Option + F 提取字段 Command + Option + C 提取常量 Command + Option + P 提取参数 八、VCS/Local History（版本控制/本地历史记录） Command + K 提交代码到版本控制器 Command + T 从版本控制器更新代码 Option + Shift + C 查看最近的变更记录 Control + C 快速弹出版本控制器操作面板 九、Live Templates（动态代码模板） Command + Option + J 弹出模板选择窗口，将选定的代码使用动态模板包住 Command + J 插入自定义动态代码模板 十、General（通用） Command + 1...Command + 9 打开相应编号的工具窗口 Command + S 保存所有 Command + Option + Y 同步、刷新 Control + Command + F 切换全屏模式 Command + Shift + F12 切换最大化编辑器 Option + Shift + F 添加到收藏夹 Option + Shift + I 检查当前文件与当前的配置文件 Control + ` 快速切换当前的scheme（切换主题、代码样式等） Command + , 打开IDEA系统设置 Command + ; 打开项目结构对话框 Shift + Command + A 查找动作（可设置相关选项） Control + Shift + Tab 编辑窗口标签和工具窗口之间切换（如果在切换的过程加按上delete，则是关闭对应选中的窗口） 十一、Other（一些官方文档上没有体现的快捷键） Command + Shift +8 竖编辑模式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java基础语法笔记]]></title>
      <url>%2F2016%2F11%2F30%2FJava%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[本身并不是IT行业，此为兴趣，更近较慢。 关键字关键字概述被Java语言赋予特定含义的单词 关键字特点组成关键字的字母全部小写 关键字注意事项got和const作为保留字存在，目前并不使用 12345678910/*关键字:被Java语言赋予特定含义的单词特点:组成关键字的字母全部小写注意:保留goto和const,编辑器和IDE关键字有颜色标记*/Class KeyWord&#123; public static void main(String[] args)&#123; System.out.println("HelloWorld"); &#125;&#125; 判断关键字class HelloWorld public static void main String System 常用关键字数据类型的关键字class interface byte short int long float double char booleanvoid 数据类型值的关键字true flase null 流程控制的关键字if else switch case default while do for break contunereturn 访问权限修饰符的关键字private protected public 类、函数、变量修饰符的关键字abstract final static synchronize 类与类之间关系的关键字extends implements 建立实例引用实例判断实例的关键字new this super instanceof 异常处理的关键字try catch finally throw throws 用于包的关键字package import 标识符标识符就是给类、接口、方法、变量等起名字时候使用的字符序列 组成规则英文大小写字母、数字字符、$和_ 注意事项 不能以数字开头不能使Java中的关键字区分大小写 12345678910111213141516171819202122232425262728293031323334/*1.标识符:给类、接口、方法、变量等起名字时候使用的字符序列2.组成规则:英文字母大小写、数字字符、$和_3.注意事项:不能以数字开头不能使Java中的关键字区分大小写4.标识符常见命名规则:·建名知意class Student&#123;&#125;·包:其实是文件夹，用于把相同的类名进行区分，全部小写单级:xzy多级cn.xzy.cherry·类或者接口:一个单词:单词的首字母必须大写:Student,Dog多个单词:每个单词的首字母必须大写:HelloWorld,StudentName·方法或者变量一个单词:单词首字母小写:main,age;多个单词:从第二个单词开始，每个单词首字母大写:studentAge,showName()·常量一个单词:全部大写:PI多个单词:全部大写单词下划线隔开:MY_NAME*/class MakeNameDemo&#123; public static void main(String[] args)&#123; //正确做法 int i = 100; //int 1y = 100; //int public = 100; int Public = 100; &#125;&#125; *哪些标识符不合法 HeloWorld DataClass _983 $bS5 `class` `DataClass#` `97.1` `Hello World` 注释注释概述用于解释说明程序的文字 Java中注释分类格式单行注释://注释文字多行注释:/注释文字/文档注释:被Javadoc解析生成说明文档 1234567891011//单行注释/*多行注释多行注释不能嵌套 */class ZhushiDemo&#123; //main方法是主方法是程序入口被jvm调用 public static void main(String[] args) &#123; System.out.println("好好学习"); &#125;&#125; 注释是一个程序员必须要具有的良好编程习惯初学者编写代码可以养成习惯:先写注释在写代码因为代码仅仅是思想的一种体现形式 12345678910111213141516/*需求:写个Java程序，输出HelloWorld分析:1.写个Java程序,必须定义类2.把数据输出说明程序可以独立运行，必须定义main方法3.把数据输出必须使用输出语句实现:1.Java语言提供了一个关键字:class用来定义类，后面跟类名2.main方法格式固定3.输出语句固定*/class HelloWorld&#123; public static void main(String[] args)&#123; System.out.println("HelloWorld"); &#125;&#125; 常量常量的概述在程序执行过程中其值不能发生改变 Java常量分类字面值常量自定义常量 常量类型 ·字符串常量:双引号括起来的内容·整数常量:所有整数·小数常量:所有小数·字符常量:单引号括起来的内容·布尔常量:true和false·空常量:null 123456789101112131415161718192021222324252627282930/*常量: 在程序执行过程中，其值不发生改变分类: 字面值常量 自定义常量字面值常量 1.字符串常量:双引号括起来的内容:"hello","你好","World" 2.整数常量:所有整数:100,200 3.小数常量:所有小数:213.4,0.1 4.字符常量:单引号括起来的内容:'A','a','0' 5.布尔常量:true和false:true,false; 6.空常量:null:null */class ConstantDemo&#123; public static void main(String[] args) &#123; //字符串输出 System.out.println("你好"); //整数常量 System.out.println(111); //小数常量 System.out.println(1.1); //字符常量 System.out.println('a'); //布尔常量 System.out.println(true); System.out.println(false); &#125;&#125; Java针对整数常量提供了四种表现形式二进制、八进制、十进制、十六进制 进制概述进制就是位进制，是一种规定好的进位方法。X进制表示逢X进一位。 不同进制的数据组成 ·二进制:由0,1组成，以0b开头·八进制:由0,1..7组成，以0开头·十进制:由0,1..9组成，整数默认十进制·十六进制:由0,1..9,abcdef(大小写均可)，以0x开头 进制转换：略。有符号的数据表示法在计算机内，有符号数有三种表示法，原码，反码，补码。所有数据运算都是采用补码进行的 原码: 就是二进制定点表示法，即最高位为符号位，0表示正，1表示负，其余位表示数值大小 反码: 正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外 补码:正数的补码与其原码相同：负数的补码是在其反码的末尾加1 已知某数X的原码为10110100B求反码和补码。11001011 11001100 已知某数X的补码11101110B，求原码。 10010010 变量变量概述在执行过程中，在某个范围内，其值可以发生改变的量，可以想成未知数 变量定义格式数据类型 变量名 = 初始化值注意:格式是固定的1.从本质上来讲，变量是内存中的一小块区域使用变量名来访问这块区域，因此每一个变量使用前必须先声明。然后进行赋值，才能够使用。2.定义变量是为了不断存放同一类型的常量，并可以重复使用。 ---- 数据类型 基本数据类型(字符型(char),布尔型(boolean),数值型(整数类型(byte,short,int.long),浮点类型(float,double))) 引用数据类型(类(class),接口(interface),数组([])) 类型 占用存储空间 范围 byte 1字节 -128~127 short 2字节 -2^15~2^15-1 int 4字节 -2^31~2^31-1 long 8字节 -2^53~2^53-1 float 4字节 -3.403E38~3.403E38 double 8字节 -1.798E308~1.798E308 整数默认int,小数默认double,长整型后缀用大L标记 使用变量注意事项 ·作用于：变量定义在哪一级的大括号中，哪个大括号的范围就是这个变量的作用域，相同作用域中不能定义两个同名变量·初始化值:没有初始化值不能使用·在一行上建议只定义一个变量，可以定义多个，但是不建议 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*数据类型:Java是一种强类型语言，针对每一种数据类型都明确了数据类型。数据类型分类: 基本数据类型 引用数据类型(类，接口，数值)基本数据类型:4类8种 整数 占用字节数 byte 1字节 short 2字节 int 4字节 long 8字节 浮点数 float 4字节 double 8字节 字符 char 2字节 布尔 boolean 1字节 整数默认int,小数默认double,长整型后缀用大L标记,单精度使用后缀F */class DataTypeDemo &#123; public static void main(String[] args) &#123; //定义变量的格式: //数据类型 变量名 = 初始化值 //定义一个字节变量 byte b = 10 System.out.println(b); //定义一个短整型变量 short a = 20 System.out.println(a); //定义一个整型变量 int ab = 100; System.out.println(ab); //定义一个长整型变量 long abc = 1000000000L; System.out.println(abc); //定义浮点数变量 float f = 12.234F; System.out.println(abc); //定义字符变量 char ch = 'a'; System.out.println(ch); //定义布尔变量 boolean flag = true; System.out.println(flag); &#125;&#125; 123456789101112131415161718192021222324252627/*使用变量的时候要注意的问题: 作用域： 变量定义在哪一级的大括号中，哪个大括号的范围就是这个变量的作用域，相同作用域中不能定义两个同名变量 初始化值 没有初始化值不能使用 在使用前给值就行，不一定非要在定义的时候立即给值 在一行上建议只定义一个变量，可以定义多个，但是不建议 */class DataTypeDemo2&#123; public static void main(String[] args) &#123; //定义变量 int x = 100; //错误，不能同名 int x = 200; //错误 必须初始化值 //int y; //System.out.println(y); int z; z = 200; System.out.println(z); int a = 10;int b = 20;int c = 20;//可以但不建议 int e,d; &#125;&#125; +是一个运算符，做数据的加法 boolean类型不能转换为其他的数据类型 默认转换: byte,short,char--int--long--float--double byte,short,char相互之间不转换，参与运算首先转换为int 强制转换:从大到小 目标类型 变量名 = (目标类型)(被转换的数据) 1234567891011121314151617181920212223242526/* +是一个运算符，做数据的加法 一般来说，运算的时候要求参与的数据类型必须一致 boolean类型不能转换为其他的数据类型 默认转换: byte,short,char--int--long--float--double byte,short,char相互之间不转换，参与运算首先转换为int 强制转换: 目标类型 变量名 = (目标类型)(被转换的数据) 注意: 不要随意使用强制转换，隐含了损失精度问题 */class DataTypeDemo3&#123; public static void main(String[] args) &#123; //两个int类型相加 System.out.println(3 + 4); //定义一个byte和int做加法 byte a = 3; int b = 3; int c = a + b; byte c = a + b;//损失精度报错 byte c = (byte)(a + b);//强制转换 &#125;&#125; 12345678910111213141516/* 思考题:问题？ double d = 12.345; float f = d; */class DataTypeDemo5 &#123; public static void main(String[] args) &#123; //double赋值给float,加强制转换 double d = 12.345; float f = (float)d; //看看下面两个定义的区别? float f1 = (float)12.345;//通过double强制转换，不建议 float f2 = 12.345F; &#125;&#125; 1234567891011121314/* 面试题 byte b1 = 3,b2 = 4,b; b = b1 + b2; b = 3 + 4; 哪一句编译失败 */class DataTypeDemo5&#123; public static void main(String[] args) &#123; byte b1 = 3,b2 = 4,b; b = b1 + b2;//损失精度，类型提升，编译出错 b = 3 + 4;//正确，常量计算看是否在范围内，如果不在就报错 &#125;&#125; 12345678910111213/*看程序写结果 记住3个值 'a' = 97; 'A' = 65; '0' = 48; */class DataTypeDemo8 &#123; public static void main(String[] args) &#123; System.out.println('a'); System.out.println('a' + 1);//'a' = 97 &#125;&#125; 12345678910/*看程序写结果 字符串数据和其他数据做+，结果是字符串类型这里的加是字符串连接符 */class DataTypeDemo7 &#123; public static void main(String[] args) &#123; System.out.println("hello"+'a'+1); //helloa1 System.out.println('a' + 1 + "hello");//98hello &#125;&#125; 数据类型中补充的小问题1.在定义Long和Float类型变量的时候，要加L和F整数默认int类型，浮点数默认double类型byte,short在定义的时候接受的是一个int类型的值,不过不在范围内,就报错2.byte b1 = 127;byte b2 = (byte)127; //127byte b3 = (byte)128; //-128byte b4 = (byte)128; //-127byte范围: -128 ~ 1273.数据类型转换至默认转换byte,short,char –int –long –flout –double 整数和浮点数的底层存储结构不同 运算符算术运算符简单的+,-,*,/.+的几种作用加法、正数、字符串连接符 除法的时候要注意的问题:正数相除，只能得到小数想要得到小数，可以*1.0 /和%的区别++和–的应用单独使用效果相同参与运算使用，在操作数的前后效果不同 1234567891011121314151617181920212223242526/*运算符:对常量和变量进行操作的服符号分类: 算数运算符 +,-.*,/,++,--，% 注意: 整数相除只能得到整数，如果得到小数，必须把数据变换为浮点型 /获取的是除法操作的商，%获取除法操作的余数 */class OperatorDemo&#123; public static void main(String[] args) &#123; int x = 3;//把3赋值给int类型的x int y = 4; System.out.println(x+y); System.out.println(x-y); System.out.println(x*y);//只能得到整数 System.out.println(x/y);//只能得到整数 //如果只想得到小数，把操作数据中任意一个改为浮点型 System.out.println(x*1.0*y); System.out.println(x*1.0/y); //取余 System.out.println(x%y); //得到余数3 &#125;&#125; 123456789101112131415161718192021222324252627282930313233/*++，--运算符的使用 单独使用:放在操作费前后都一样 参与运算使用: 放在前面，先自增或者自减，再参与运算。 放在后面，先参与运算，再自增或者自减。作用:就是对变量进行自增或者自减 */class OperatorDemo2&#123; public static void main(String[] args) &#123; int i = 3; int y = 4; //字符串拼接 //System.out.println("x"+x); //x++; //y++; //--y; //--x; System.out.println("x"+x);//单独使用 //System.out.println(10++);不可这样做 //参与运算使用 int a = 3; int b = 4; int c = a++; int d = b--; System.out.println(a);//4 System.out.println(b);//3 System.out.println(c);//3 System.out.println(d);//4 &#125;&#125; 12345678910111213141516class OperatorDemo3&#123; public static void main(String[] args) &#123; int a = 10; int b = 10; int c = 10; a = b++; c = --a; b = ++a; System.out.println(a);//9 System.out.println(b);//10 System.out.println(c);//8 int x = 4; int y = (x++)+(++x)+(x*10); System.out.println(x);//70 &#125;&#125; 赋值运算符符号=、+=、-=、*=、/=、%==为基本赋值运算符，其他的为扩展运算符12345678910111213141516171819/* 赋值运算符: 基本赋值运算符:= 扩展赋值运算符:+=,-=,*=,/= */class operatorDemo&#123; public static void main(String[] args) &#123; //定义一个变量 int x = 10; int a,b; a = b = 10; System.out.println(a);//10 System.out.println(b);//10 int y = 10; y+=20; System.out.println(y);//30 &#125;&#125; 关系运算符注:比较运算符的结果都是blooean类型,true或者false比较运算符==不能写成=123456789101112131415161718/* 比较运算符: ==、!=、&gt;、&gt;=、&lt;、&lt;= 特点:无论操作简单还是复杂结果都是boolean类型 */class OperatorDemo&#123; public static void main(String[] args) &#123; int x = 3; int y = 4; int z = 3; System.out.println(x == y); System.out.println(x != y); System.out.println(x &gt;= y); System.out.println(x &lt;= y); System.out.println(x &gt; y); System.out.println(x &lt; y); &#125;&#125; 逻辑运算符 运算符 运算 范例 结果 &amp; 与 f&amp;t f &amp;&amp; 短路与 f&amp;&amp;t f ^ 异或 f ^ t t ！ 非 !t f \ 或 f \ t t \ \ 短路或 f\ \ t t 逻辑运算符用于连接布尔表达式在Java中不可写成3&lt;x&lt;6,只能写成3&lt;x&amp;x&lt;6 &amp;和&amp;&amp;的区别：&amp;:无论左边真假，右边都进行计算&amp;&amp;；如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算 1234567891011121314151617181920212223242526/* 逻辑运算符 &amp;、&amp;&amp;、|、||、！、^ 特点: 逻辑运算符一般用于连接Boolean类型的表达式或者值 表达式：就是用运算符把常量或者变量连接起来的符合Java语法的式子 算数表达式:a+b 比较表达式:a==b 结论: 逻辑与:有false就false 逻辑或:有true就true 逻辑异或:相同的为false，不同为true，情侣关系 逻辑非:非false则true，非true则false &amp;&amp;和&amp;的区别 最终结果一样 &amp;&amp;具有短路效果，左边false右边不执行 开发中常用逻辑运算符 */class OperatorDemo&#123; public static void main(String[] args) &#123; int a = 3; int b = 4; int c = 5; System.out.println((a&gt;b)&amp;(a&gt;c)); &#125;&#125; 位运算符1234567891011121314151617181920/*位运算符&amp;,|,^,&lt;&lt;,&gt;&gt;,&gt;&gt;&gt;注意：做位运算，首先把数据转为二进制。 */class OperatorDemo&#123; public static void main(String[] args) &#123; int a = 3; int b = 4; //运算在二进制下进行运算 System.out.println(3&amp;4);//有0则0 System.out.println(3|4);//有1则1 System.out.println(3^4);//相同则0不同则1 特点:a^b^b,位异或两次，该数不变 System.out.println(3~4);//按位取反，得补码，转原码 &#125; /* 先把数据换算成二进制 */&#125; 123456789101112131415161718192021222324252627282930 /* 实现两个整数变量的交换 */ class OperatorDemo2&#123; public static void main(String[] args) &#123; int a = 10; int b = 20; //方式1第三方变量 /*int c = a; a = b; b = c; System.out.println(a+"----"+b); */ //方式2 /*a = a ^ b; b = a ^ b; a = a ^ b; System.out.println(a+"----"+b);*/ //方式3 /* a = a + b; b = a - b; a = a - b; System.out.println(a+"----"+b);*/ //方式4 /* b = (a+b)-(a=b); System.out.println(a+"----"+b);*/ &#125;&#125; 1234567891011121314/*&lt;&lt;:左边最高位丢弃，右边补齐0&gt;&gt;:最高位是0，左边补齐0；最高位是1，左边补1&gt;&gt;&gt;:无论最高位是0还是1，左边补齐0 */class OperatorDemo3&#123; public static void main(String[] args) &#123; System.out.println(3&lt;&lt;2);//左边的数据*2的移动次幂:12 System.out.println(24&gt;&gt;2);//左边的数据/2的移动次幂:6 System.out.println(24&gt;&gt;&gt;2); &#125; //如何最有效率计算2*8 //2&lt;&lt;3&#125; 三目运算符格式(关系表达式)？表达式1:表达式2；如果条件为true，运算后结果为表达式1如果条件为false，运算后结果为表达式2 123456789101112131415/* 三目运算符: 表达式?表达式1:表达式2; 根据表达式返回true或者false； */class OperatorDemo&#123; public static void main(String[] args) &#123; int x = 100; int y = 200; //int z = (x&gt;y)?x:y; //int z = (x&lt;y)?x:y; ////int z = (x==y)?x:y; &#125;&#125; 123456789101112131415161718192021/* 获取两个整数最大值 获取三个整数最大值 比较两个整数是否相同 */class OperatorTest&#123; public static void main(String[] args) &#123; int x = 100; int y = 200; int max = (x&gt;y)?x:y; System.out.println(max); int a = 10; int b = 20; int c = 30; int m = ((a&gt;b)?a:b)&gt;c?((a&gt;b)?a:b):c; System.out.println(m); int f = 100; int g = 200; System.out.println(f==g); &#125;&#125; 键盘录入键盘录入概述数据是变化的，提高程序的灵活性 1234567891011121314151617181920212223/*A:导包 格式 import java.util.Scanner; 位置 在class上面B:创建键盘录入对象 格式 Scanner s = new Scanner(System.in);C:获取对象数据 格式 int x = s.nextInt(); */import java.util.Scanner;class ScannerDemo&#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); int a = nextInt(); System.out.prinln("输入的数是"+a); &#125;&#125; 练习12345678910/*键盘录入两个数据，并对两个数据求和*/import java.util.Scanner;class ScannerDemo2&#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); int a = s.nextInt(); int b = s.nextInt(); System.out.println(a+b); &#125;&#125; 1234567891011 /*键盘录入两个数据，并对两个数最大值*/import java.util.Scanner;class ScannerDemo3&#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); int a = s.nextInt(); int b = s.nextInt(); System.out.println((a&gt;b)?a:b); &#125;&#125; 语句流程控制语句流程控制语句分类 顺序结构选择结构循环结构 顺序结构程序中最简单最基本的流程控制，没有特定语法结构，按照代码先后顺序，一次执行，程序大多数代码这样执行。总的来说前面的先执行，后面的后执行。 12345st=&gt;start: 开始op1=&gt;operation: 语句Aop2=&gt;operation: 语句Be=&gt;end: 结束st-&gt;op1-&gt;op2-&gt;e 选择结构也被成为分支结构选择结构与特定的语法规则，代码要执行具体的逻辑运算进行判断，逻辑计算结果有两个，所以产生选择，按照不同的选择执行不同的代码。Java语言提供两种选择语句 if语句switch语句 if语句格式1123if(关系表达式)&#123; 语句体&#125; 执行流程首先判断关系表达式看其结果是true还是false如果是true就执行语句体如果是false就不执行语句体 注意事项关系表达式无论多么复杂，结果必须是boolean类型。if语句如果只有一条语句，大括号可以省略，如果多条语句，就不能省略。一般来说有左大括号就没有分号,有分号就没有左大括号 123456789101112131415161718192021222324/* 选择语句： if语句 switch语句 if语句： 格式1 格式2 格式3 if语句的格式 if(比较表达式)&#123; 语句体; &#125; 执行流程： 先算表达式，结果true就执行语句体，否则不执行。 */class XuanZeJieGouDemo&#123; public static void main(String[] args) &#123; int x = 10; if (x==10) &#123; System.out.println("x=10"); &#125; &#125;&#125; 语句格式212345if(关系表达式)&#123; 语句1;&#125;else&#123; 语句2;&#125; 执行流程首先判断关系表达式看其结果是true还是false如果是true就执行语句体1如果是false就执行语句体2 123456789101112131415161718192021222324/* if语句格式2: if(比较表达式)&#123; 语句体1 &#125;else&#123; 语句体2 &#125; 执行流程 首先判断关系表达式看其结果是true还是false 如果是true就执行语句体1 如果是false就执行语句体2 */class XuanZeJieGouDemo2&#123; public static void main(String[] args) &#123; //判断两个数据是否相等 int a = 10; int b = 20; if (a==b) &#123; System.out.println("相等"); &#125;else&#123; System.out.println("不相等"); &#125; &#125;&#125; 1234567891011121314151617181920212223242526/* if语句格式2的练习 a:判断两个数中较大的值 b:判断一个数是奇数还是偶数 */import java.util.Scanner;class XuanZeJieGouTest&#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); int a = s.nextInt(); int b = s.nextInt(); /*int max; if (a&gt;b) &#123; max = a; &#125;else&#123; max = b &#125; System.out.println(max);*/ if(a%2==0)&#123; System.out.println("这个数是偶数"); &#125;else&#123; System.out.println("这个数是奇数"); &#125; &#125;&#125; if语句格式3123456789if(关系表达式)&#123; 语句体1;&#125;else if(关系表达式2)&#123; 语句体2;&#125;……else&#123; 语句体n+1;&#125; 执行流程判断关系表达式1看结果是true还是false如果是true执行语句体1如果false继续判断关系表达式2看结果是true还是false 1234567891011121314151617181920212223242526272829303132333435/* if语句格式3 if(比较表达式1)&#123; 语句体1； &#125;else if&#123; 语句体2 &#125;else&#123; 语句体3 &#125; 执行流程 判断关系表达式1看结果是true还是false 如果是true执行语句体1 如果false继续判断关系表达式2看结果是true还是false */import java.util.Scanner;class XuanZeJieGouDemo3&#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); int a = s.nextInt(); if (a&gt;=90&amp;&amp;a&lt;=100) &#123; System.out.println("优秀"); &#125;else if (a&lt;90&amp;&amp;a&gt;=80) &#123; System.out.println("好"); &#125;else if (a&lt;80&amp;&amp;a&gt;=70) &#123; System.out.println("良"); &#125;else if (a&lt;70&amp;&amp;a&gt;=60) &#123; System.out.println("及格"); &#125;else if(a&lt;60&amp;&amp;a&gt;=0)&#123; System.out.println("不及格"); &#125;else&#123; System.out.println("数据有误"); &#125; &#125;&#125; 1234567891011121314151617181920212223/* 三种if语句分别适合做什么事情 格式1:适合单个判断 格式2:适合两个判断 格式3:适合多个判断 */import java.util.Scanner;class XuanZeJieGou&#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); int x = s.nextInt(); int y; if(x&gt;=3)&#123; y=2*x+1; &#125;else if(x&lt;3&amp;&amp;x&gt;=-1)&#123; y = 2*x; &#125;else if(x&lt;=-1)&#123; y = 2*x-1; &#125; System.out.println(y); &#125;&#125; switch语句格式123456789switch(表达式) &#123; case 值1： 语句体1; break; case 值2： 语句体2; break; … default： 语句体n+1; break; &#125; switch语句解释switch表示这是switch语句表达式的取值：byte,short,int,charJDK5以后可以是枚举JDK7以后可以是Stringcase后面跟的是要和表达式进行比较的值语句体部分可以是一条或多条语句break表示中断，结束的意思，可以结束switch语句default语句表示所有情况都不匹配的时候，就执行该处的内容，和if语句的else相似。 执行流程首先计算出表达式的值其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结束。最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。 12345678910111213141516171819202122232425262728293031import java.util.Scanner;class SwitchDemo&#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); int a = s.nextInt(); switch(a)&#123; case 1: System.out.println("周一"); break; case 2: System.out.println("周二"); break; case 3: System.out.println("周三"); break; case 4: System.out.println("周四"); break; case 5: System.out.println("周五"); break; case 6: System.out.println("周六"); break; case 7: System.out.println("周日"); break; &#125; &#125;&#125; 注意事项注意事项case后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的default可以省略吗? 可以省略。一般不建议。除非判断的值是固定的。(单选题)break可以省略吗? 可以省略，一般不建议。否则结果可能不是你想要的default的位置一定要在最后吗? 可以出现在switch语句任意位置。switch语句的结束条件: 遇到break 执行到程序的末尾 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* 模拟单项选择题。 分析： A:出一个选择题，然后供你选择。 B:键盘录入选择的数据。 C:根据选择来给出你选择的结论。*/import java.util.Scanner;class SwitchTest2 &#123; public static void main(String[] args) &#123; //出一个选择题，然后供你选择。 //由于我们现在没有办法键盘录入得到一个'A','B' //这样的东西，我就用65，66这样的值替代 //将来我们获取到这样的值以后，强制转换为字符类型 System.out.println("下面的几个人你最爱谁?"); System.out.println("65 林青霞"); System.out.println("66 张曼玉"); System.out.println("67 刘德华"); System.out.println("68 王力宏"); //键盘录入选择的数据。 Scanner sc = new Scanner(System.in); System.out.println("请输入你的选择："); int choiceNumber = sc.nextInt(); //强制转换为字符类型 char choice = (char) choiceNumber; switch(choice) &#123; case 'A': System.out.println("恭喜你,选择正确"); break; case 'B': System.out.println("不好意思，你选择有误"); break; case 'C': System.out.println("不好意思，你选择有误"); break; case 'D': System.out.println("不好意思，你选择有误"); break; default: System.out.println("没有该选项"); break; &#125; &#125;&#125; 循环结构循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形成死循环 循环语句的组成初始化语句： ·一条或者多条语句，这些语句完成一些初始化操作。 判断条件语句： ·这是一个boolean 表达式，这个表达式能决定是否执行循环体。循环体语句： ·这个部分是循环体语句，也就是我们要多次做的事情。 控制条件语句： ·这个部分在一次循环体结束后，下一次循环判断条件执行前执行。通过用于控制循环条件中的变量，使得循环在合适的时候结束。 for循环语句格式for(初始化语句;判断条件语句;控制条件语句) { 循环体语句; }执行流程 A:执行初始化语句 B:执行判断条件语句，看其结果是true还是false 如果是false，循环结束。 如果是true，继续执行。 C:执行循环体语句 D:执行控制条件语句 E:回到B继续 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* 循环语句：for循环,while循环,do...while循环。 for循环格式： for(初始化语句;判断条件语句;控制条件语句) &#123; 循环体语句; &#125; 执行流程： A:执行初始化语句 B:执行判断条件语句,看其返回值是true还是false 如果是true，就继续执行 如果是false，就结束循环 C:执行循环体语句; D:执行控制条件语句 E:回到B继续。 注意事项： A:判断条件语句无论简单还是复杂结果是boolean类型。 B:循环体语句如果是一条语句，大括号可以省略；如果是多条语句，大括号不能省略。建议永远不要省略。 C:一般来说：有左大括号就没有分号，有分号就没有左大括号 需求：请在控制台输出10次"HelloWorld"*/class ForDemo &#123; public static void main(String[] args) &#123; //最原始的做法 System.out.println("HelloWorld"); System.out.println("HelloWorld"); System.out.println("HelloWorld"); System.out.println("HelloWorld"); System.out.println("HelloWorld"); System.out.println("HelloWorld"); System.out.println("HelloWorld"); System.out.println("HelloWorld"); System.out.println("HelloWorld"); System.out.println("HelloWorld"); System.out.println("----------"); //这种做法不好,代码的重复度太高。 //所以呢，我们用循环改进 for(int x=1;x&lt;=10;x++) &#123; System.out.println("HelloWorld"); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132/* 需求：请在控制台输出数据1-10*/class ForDemo2 &#123; public static void main(String[] args) &#123; //原始做法 System.out.println(1); System.out.println(2); System.out.println(3); System.out.println(4); System.out.println(5); System.out.println(6); System.out.println(7); System.out.println(8); System.out.println(9); System.out.println(10); System.out.println("-------------"); //如何改进呢?用循环改进 for(int x=1; x&lt;=10; x++) &#123; System.out.println(x); &#125; System.out.println("-------------"); //从0开始 for(int x=0; x&lt;10; x++) &#123; System.out.println(x+1); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041/* 需求：求出1-10之间数据之和 分析： 0+1=1 1+2=3 3+3=6 6+4=10 10+5=15 ... 由此可见我们要定义两个变量： 一个变量用于存储第一个加数，第一个加数其实保存的是以前的所有数据和。默认初始化值应该是0。 一个变量用于存储第二个加数，第二个加数其实就是每次的数据变化的值。 求和思想。 */class ForDemo3 &#123; public static void main(String[] args) &#123; //原始做法 System.out.println(1+2+3+4+5+6+7+8+9+10); //定义第一个加数 int sum = 0; for(int x=1; x&lt;=10; x++) &#123; //这里的x其实是第二个加数 sum = sum + x; /* 0 + 1 = 1 1 + 2 = 3 3 + 3 = 6 ... */ //sum += x; &#125; System.out.println("sum:"+sum); &#125;&#125; 12345678910111213141516171819202122232425/* 需求：求5的阶乘。 什么是阶乘呢? n! = n*(n-1)! 规则 n! = n*(n-1)*(n-2)*...*3*2*1 求和思想。 求阶乘思想。*/class ForDemo5 &#123; public static void main(String[] args) &#123; //定义最终结果变量 int jc = 1; //这里的x其实可以直接从2开始 //for(int x=1; x&lt;=5; x++) for(int x=2; x&lt;=5; x++) &#123; jc *=x; &#125; System.out.println("1-5的阶乘是："+jc); &#125;&#125; 12345678910111213141516171819202122232425262728293031/* 练习： 请在控制台输出满足如下条件的五位数 个位等于万位 十位等于千位 个位+十位+千位+万位=百位 分析： A:五位数就告诉了我们范围。 B:分解每一个五位数的个，十，百，千，万位上的数据 C:按照要求进行判断即可*/class ForDemo7 &#123; public static void main(String[] args) &#123; //五位数就告诉了我们范围。 for(int x=10000; x&lt;100000; x++) &#123; //分解每一个五位数的个，十，百，千，万位上的数据 int ge = x%10; int shi = x/10%10; int bai = x/10/10%10; int qian = x/10/10/10%10; int wan = x/10/10/10/10%10; //按照要求进行判断即可 if((ge==wan) &amp;&amp; (shi==qian) &amp;&amp; (ge+shi+qian+wan==bai)) &#123; System.out.println(x); &#125; &#125; &#125;&#125; while循环while循环语句格式基本格式 while(判断条件语句) { 循环体语句; }扩展格式 初始化语句; while(判断条件语句) { 循环体语句; 控制条件语句; } 12345678910111213141516171819202122232425262728293031323334353637/* while循环的基本格式： while(判断条件语句) &#123; 循环体语句; &#125; 扩展格式： 初始化语句; while(判断条件语句) &#123; 循环体语句; 控制条件语句; &#125; 通过这个格式，我们就可以看到其实和for循环是差不多的。 for(初始化语句;判断条件语句;控制条件语句) &#123; 循环体语句; &#125;*/class WhileDemo &#123; public static void main(String[] args) &#123; //输出10次"HelloWorld" //for语句版 for(int x=0; x&lt;10; x++) &#123; System.out.println("HelloWorld"); &#125; System.out.println("--------------"); //while语句版 int x=0; while(x&lt;10) &#123; System.out.println("HelloWorld"); x++; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243/* 练习：用while循环实现 左边：求出1-100之和 右边：统计水仙花数有多少个 初始化语句; while(判断条件语句) &#123; 循环体语句; 控制条件语句; &#125; for(初始化语句;判断条件语句;控制条件语句) &#123; 循环体语句; &#125;*/class WhileDemo2 &#123; public static void main(String[] args) &#123; //求出1-100之和 //for语句版本 int sum = 0; for(int x=1; x&lt;=100; x++) &#123; sum+=x; &#125; System.out.println("sum:"+sum); System.out.println("--------"); //while语句版本 int sum2 = 0; int y=1; while(y&lt;=100) &#123; sum2+=y; y++; &#125; System.out.println("sum2:"+sum2); System.out.println("--------"); &#125;&#125; 循环结构区别for循环语句和while循环语句可以等价转换，但还是有些小区别的使用区别： 控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消失，能够提高内存的使用效率。场景区别： for循环适合针对一个范围判断进行操作 while循环适合判断次数不明确操作 1234567891011121314151617181920212223242526272829/* while循环和for循环的区别? 使用区别：如果你想在循环结束后，继续使用控制条件的那个变量，用while循环，否则用for循环。不知道用for循环。 因为变量及早的从内存中消失，可以提高内存的使用效率。 其实还有一种场景的理解: 如果是一个范围的，用for循环非常明确。 如果是不明确要做多少次，用while循环较为合适。 举例：吃葡萄。*/class WhileDemo4 &#123; public static void main(String[] args) &#123; //for循环实现 for(int x=0; x&lt;10; x++) &#123; System.out.println("学习Java技术哪家强,中国北京传智播客"); &#125; //这里不能在继续访问了 //System.out.println(x); //while循环实现 int y = 0; while(y&lt;10) &#123; System.out.println("学习Java技术哪家强,中国北京传智播客"); y++; &#125; //这里是可以继续访问的 System.out.println(y); &#125;&#125; do..while循环格式基本格式 do { 循环体语句; }while((判断条件语句);扩展格式 初始化语句; do { 循环体语句; 控制条件语句; } while((判断条件语句); 循环结构注意事项三种循环语句其实都可以完成一样的功能，也就是说可以等价转换，但还是有小区别的:do…while循环至少会执行一次循环体。for循环和while循环只有在条件成立的时候才会去执行循环体注意事项：写程序优先考虑for循环，再考虑while循环，最后考虑do…while循环。如下代码是死循环while(true){}for(;;){} 123456789101112131415161718192021222324252627282930/* 注意死循环： A:一定要注意控制条件语句控制的那个变量的问题，不要弄丢了，否则就容易死循环。 B:两种最简单的死循环格式 while(true)&#123;...&#125; for(;;)&#123;...&#125; */class DoWhileDemo3 &#123; public static void main(String[] args) &#123; int x = 0; while(x &lt; 10) &#123; System.out.println(x); x++; &#125; System.out.println("--------------"); /* while(true) &#123; System.out.println("今天我很高兴，学习了死循环"); &#125; */ for(;;)&#123; System.out.println("今天我很高兴，学习了死循环"); &#125; //System.out.println("--------------"); &#125;&#125; 循环嵌套123456789101112131415161718192021222324252627 需求：请输出一个4行5列的星星(*)图案。 结果： ***** ***** ***** ***** 循环嵌套：就是循环语句的循环体本身是一个循环语句。 通过结果我们知道这样的一个结论： 外循环控制行数 内循环控制列数*/class ForForDemo &#123; public static void main(String[] args) &#123; //同样的代码出现了4次，说明我们程序写的不好，用循环改进 for(int y=0; y&lt;4; y++) &#123; for(int x=0; x&lt;5; x++) &#123; System.out.print("*"); &#125; //我们可以通过空的输出语句实现换行：System.out.println(); System.out.println(); &#125; &#125;&#125; 12345678910111213141516171819/* 需求：请输出下列的形状 * ** *** **** ******/class ForForDemo2 &#123; public static void main(String[] args) &#123; for(int x=0; x&lt;5; x++) &#123; for(int y=0; y&lt;=x; y++) &#123; System.out.print("*"); &#125; System.out.println(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829/* 需求：在控制台输出九九乘法表。 注意： '\x' x表示任意，这种做法叫转移字符。 '\t' tab键的位置 '\r' 回车 '\n' 换行*/class ForForDemo3 &#123; public static void main(String[] args) &#123; for(int x=0; x&lt;9; x++) &#123; for(int y=0; y&lt;=x; y++) &#123; System.out.print("*"); &#125; System.out.println(); &#125; System.out.println("--------------"); //为了使用数据，我们从1开始 for(int x=1; x&lt;=9; x++) &#123; for(int y=1; y&lt;=x; y++) &#123; System.out.print(y+"*"+x+"="+y*x+"\t"); &#125; System.out.println(); &#125; &#125;&#125; 跳转控制语句breakbreak的使用场景： 在选择结构switch语句中 在循环语句中 离开使用场景的存在是没有意义的 break的作用： 跳出单层循环 跳出多层循环 带标签的跳出 格式： 标签名: 循环语句 标签名要符合Java的命名规则 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* 控制跳转语句： break:中断 continue:继续 return:返回 break:中断的意思 使用场景： A:switch语句中 B:循环语句中。 (循环语句中加入了if判断的情况) 注意：离开上面的两个场景，无意义。 如何使用呢? A:跳出单层循环 B:跳出多层循环 要想实现这个效果，就必须知道一个东西。带标签的语句。 格式： 标签名: 语句*/class BreakDemo &#123; public static void main(String[] args) &#123; //在 switch 或 loop 外部中断 //break; //跳出单层循环 for(int x=0; x&lt;10; x++) &#123; if(x == 3) &#123; break; &#125; System.out.println("HelloWorld"); &#125; System.out.println("over"); System.out.println("-------------"); wc:for(int x=0; x&lt;3; x++) &#123; nc:for(int y=0; y&lt;4; y++) &#123; if(y == 2) &#123; //break nc; break wc; &#125; System.out.print("*"); &#125; System.out.println(); &#125; &#125;&#125; continuecontinue的使用场景： 在循环语句中 离开使用场景的存在是没有意义的continue的作用： 单层循环对比break，然后总结两个的区别break 退出当前循环continue 退出本次循环 123456789101112131415161718192021222324252627282930313233343536373839/* continue:继续 使用场景： 循环中。离开此场景无意义。 测试，找到和break的区别： break:跳出单层循环 continue:跳出一次循环，进入下一次的执行 练习题： for(int x=1; x&lt;=10; x++) &#123; if(x%3==0) &#123; //在此处填写代码 &#125; System.out.println(“Java基础班”); &#125; 我想在控制台输出2次:“Java基础班“ break; 我想在控制台输出7次:“Java基础班“ continue; 我想在控制台输出13次:“Java基础班“ System.out.println(“Java基础班”);*/class ContinueDemo &#123; public static void main(String[] args) &#123; for(int x=0; x&lt;10; x++) &#123; if(x == 3) &#123; //break; continue; &#125; System.out.println(x); &#125; &#125;&#125; returnreturn关键字不是为了跳转出循环体，更常用的功能是结束一个方法，也就是退出一个方法。跳转到上层调用的方法。 方法方法定义及格式定义简单的说：方法就是完成特定功能的代码块 在很多语言里面都有函数的定义 函数在Java中被称为方法 格式修饰符 返回值类型 方法名(参数类型 参数名1，参数类型 参数名2…) { 函数体; return 返回值; } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/* 方法：完成特定功能的代码块。 注意：在很多语言里面有函数的定义，而在Java中函数被称为方法。 方法格式： 修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) &#123; 方法体语句; return 返回值; &#125; 详细解释： 修饰符：目前就用 public static。后面我们再详细的讲解其他的修饰符。 返回值类型：就是功能结果的数据类型。 方法名：符合命名规则即可。方便我们的调用。 参数： 实际参数：就是实际参与运算的。 形式参数；就是方法定义上的，用于接收实际参数的。 参数类型：就是参数的数据类型 参数名：就是变量名 方法体语句：就是完成功能的代码。 return：结束方法的。 返回值：就是功能的结果，由return带给调用者。 要想写好一个方法，就必须明确两个东西： A:返回值类型 结果的数据类型 B:参数列表 你要传递几个参数，以及每个参数的数据类型 需求：求两个数据之和的案例 方法的执行特点： 不调用，不执行。 如何调用呢?(有明确返回值的调用) A:单独调用,一般来说没有意义，所以不推荐。 B:输出调用,但是不够好。因为我们可能需要针对结果进行进一步的操作。 C:赋值调用,推荐方案。 */class FunctionDemo &#123; public static void main(String[] args) &#123; int x = 10; int y = 20; //方式1：单独调用 //sum(x,y); //方式2：输出调用 //System.out.println(sum(x,y)); //System.out.println(30); //方式3：赋值调用 int result = sum(x,y); //result在这里可以进行操作 System.out.println(result); &#125; /* 需求：求两个数据之和的案例 两个明确： 返回值类型：int 参数列表：2个，都是int类型。 */ public static int sum(int a,int b) &#123; //如何实现呢? //int c = a + b; //return c; //c就是a+b,所以，我可以直接返回a+b return a + b; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* 键盘录入两个数据，返回两个数中的较大值*/import java.util.Scanner;class FunctionTest &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println("请输入第一个数据:"); int a = sc.nextInt(); System.out.println("请输入第二个数据:"); int b = sc.nextInt(); int result = getMax(a,b); System.out.println("较大值是："+result); &#125; /* 需求：两个数中的较大值 两个明确： 返回值类型：int 参数列表：int a,int b */ public static int getMax(int a,int b) &#123; //if语句 /* if(a &gt; b) &#123; //System.out.println(a); return a; &#125;else &#123; //System.out.println(b); return b; &#125; */ //用三元改进 //int c = ((a &gt; b)? a: b); //return c; //由于c就是后面的式子 return ((a&gt;b)? a : b); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* 键盘录入两个数据，比较两个数是否相等 分析： 比较两个数是否相等结果是一个boolean类型。*/import java.util.Scanner;class FunctionTest2 &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println("请输入第一个数据:"); int a = sc.nextInt(); System.out.println("请输入第二个数据:"); int b = sc.nextInt(); boolean flag = compare(a,b); System.out.println(flag); &#125; /* 需求：比较两个数是否相等 两个明确： 返回值类型：boolean 参数列表：int a,int b */ public static boolean compare(int a,int b) &#123; //if语句的格式2实现 /* if(a == b) &#123; return true; &#125;else &#123; return false; &#125; */ //三元改进 //boolean flag = ((a==b)? true: false); //return flag; //继续改进 //return ((a==b)? true: false); //最终版 return a == b; &#125;&#125; 方法注意事项方法不调用不执行方法与方法是平级关系，不能嵌套定义方法定义的时候参数之间用逗号隔开方法调用的时候不用在传递数据类型如果方法有明确的返回值，一定要有return带回一个值 方法重载方法重载概述在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可 方法重载特点与返回值类型无关，只看方法名和参数列表在调用时，虚拟机通过参数列表的不同来区分同名方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* 需求：我要求数的和 我们的需求不断的发生改变，我们就对应的提供了多个求和的方法。 但是呢，他们的名字是不一样的。 而我们又要求方法命名做到：见名知意。 但是，很明显，现在没有做到。 那么，肿么办呢? 针对这种情况：方法的功能相同，参数列表不同的情况，为了见名知意，Java允许它们起一样的名字。 其实，这种情况有一个专业名词：方法重载。 方法重载： 在同一个类中，方法名相同，参数列表不同。与返回值类型无关。 参数列表不同： A:参数个数不同 B:参数类型不同*/class FunctionDemo4 &#123; public static void main(String[] args) &#123; //jvm会根据不同的参数去调用不同的功能 System.out.println(sum(10,20)); System.out.println(sum(10,20,30)); System.out.println(sum(10,20,30,40)); System.out.println(sum(10.5f,20f)); &#125; //需求1:求两个数的和 public static int sum(int a,int b) &#123; System.out.println("int"); return a + b; &#125; //需求2:求三数的和 /* public static int sum1(int a,int b,int c) &#123; return a + b + c; &#125; */ public static int sum(int a,int b,int c) &#123; return a + b + c; &#125; //需求3:求四个数的和 /* public static int sum2(int a,int b,int c,int d) &#123; return a + b + c + d; &#125; */ public static int sum(int a,int b,int c,int d) &#123; return a + b + c + d; &#125; public static float sum(float a,float b) &#123; System.out.println("float"); return a + b; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* 比较两个数据是否相等。参数类型分别为 两个byte类型，两个short类型，两个int类型，两个long类型， 并在main方法中进行测试*/class FunctionTest6 &#123; public static void main(String[] args) &#123; //测试 byte b1 = 3; byte b2 = 4; System.out.println("byte:"+compare(b1,b2)); //测试 short s1 = 5; short s2 = 5; System.out.println("short:"+compare(s1,s2)); //后面的两个自己测试 &#125; //byte类型 public static boolean compare(byte a,byte b) &#123; System.out.println("byte"); return a == b; &#125; //short类型 public static boolean compare(short a,short b) &#123; System.out.println("short"); return a == b; &#125; //int类型 public static boolean compare(int a,int b) &#123; System.out.println("int"); return a == b; &#125; //long类型 public static boolean compare(long a,long b) &#123; System.out.println("long"); return a == b; &#125;&#125; 数组数组概述数组是存储多个变量(元素)的东西(容器)这多个变量的数据类型要一致 数组的概念数组是存储同一种数据类型多个元素的集合。也可以看成是一个容器。数组既可以存储基本数据类型，也可以存储引用数据类型 数组的定义格式格式1：数据类型[] 数组名;格式2：数据类型 数组名[];注意：这两种定义做完了，数组中是没有元素值的。 数组的初始化数组的初始化概述Java中的数组必须先初始化,然后才能使用。所谓初始化：就是为数组中的数组元素分配内存空间，并为每个数组元素赋值。 数组的初始化方式动态初始化：初始化时只指定数组长度，由系统为数组分配初始值。静态初始化：初始化时指定每个数组元素的初始值，由系统决定数组长度。 数组动态初始化初始化时只指定数组长度，由系统为数组分配初始值。格式：数据类型[] 数组名 = new 数据类型[数组长度];数组长度其实就是数组中元素的个数。举例：int[] arr = new int[3];解释：定义了一个int类型的数组，这个数组中可以存放3个int类型的值。 数组的静态初始化初始化时指定每个数组元素的初始值，由系统决定数组长度。格式：数据类型[] 数组名 = new 数据类型[]{元素1,元素2,…};举例： int[] arr = new int[]{1,2,3}; 解释：定义了一个int类型的数组，这个数组中可以存放3个int类型的值，并且值分别是1,2,3。其实这种写法还有一个简化的写法int[] arr = {1,2,3}; 内存分配Java 程序在运行时，需要在内存中的分配空间。为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。 栈 存储局部变量堆 存储new出来的东西方法区 (面向对象部分讲)本地方法区 (和系统相关)寄存器 (给CPU使用) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* 数组:存储同一种数据类型的多个元素的容器。 定义格式： A:数据类型[] 数组名; B:数据类型 数组名[]; 举例： A:int[] a; 定义一个int类型的数组a变量 B:int a[]; 定义一个int类型的a数组变量 注意：效果可以认为是一样的，都是定义一个int数组，但是念法上有些小区别。推荐使用第一种。 如何对数组进行初始化呢? A:何谓初始化呢? 就是为数组开辟内存空间，并为每个数组元素赋予值 B:有几种方式呢? a:动态初始化 只指定长度，由系统给出初始化值 b:静态初始化 给出初始化值，由系统决定长度 动态初始化的格式： 数据类型[] 数组名 = new 数据类型[数组长度]; 举例： int[] arr = new int[3]; 如何获取数组中的元素呢? 通过: 数组名[索引] 索引其实就是每个元素的编号，从0开始，最大索引是数组的长度-1。*/class ArrayDemo &#123; public static void main(String[] args) &#123; //定义一个数组 //int[] a; //可能尚未初始化变量a //System.out.println(a); int[] arr = new int[3]; /* 左边： int:说明数组中的元素的数据类型是int类型 []:说明这是一个数组 arr:是数组的名称 右边： new:为数组分配内存空间。 int:说明数组中的元素的数据类型是int类型 []:说明这是一个数组 3:数组长度，其实也就是数组中元素的个数 */ System.out.println(arr); //[I@175078b 地址值。 //我要地址值没有意义啊，我就要数据值，怎么办呢? //不用担心，java为你考虑到了。 //其实数组中的每个元素都是有编号的，并且是从0开始。最大编号是数组的长度-1。 //用数组名和编号的配合就可以获取数组中的指定编号的元素。这个编号的专业叫法：索引 //通过数组名访问数据的格式是：数组名[索引]; System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); &#125;&#125; 1234567891011121314151617181920212223242526272829/* 定义一个数组，输出该数组的名称和数组元素值。 给数组元素赋值，再次输出该数组的名称和数组元素值。*/class ArrayDemo2 &#123; public static void main(String[] args) &#123; //定义一个数组 int[] arr = new int[3]; //输出数组名称 System.out.println(arr); //输出数组元素值 System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); System.out.println("----"); //给数组元素赋值 arr[0] = 100; arr[2] = 200; //输出数组名称 System.out.println(arr); //输出数组元素值 System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041/* 定义两个数组，分别输出两个数组各自的数组名及元素值。 然后给每个数组的元素重新赋值，再次分别输出两个数组各自的数组名及元素值。*/class ArrayDemo3 &#123; public static void main(String[] args) &#123; //定义第一个数组 int[] arr = new int[2]; //定义第二个数组 int[] arr2 = new int[3]; //输出数组名和元素值 System.out.println(arr); System.out.println(arr[0]); System.out.println(arr[1]); System.out.println("----"); System.out.println(arr2); System.out.println(arr2[0]); System.out.println(arr2[1]); System.out.println(arr2[2]); System.out.println("----"); //给元素重新赋值 arr[1] = 20; arr2[1] = 30; arr2[0] = 40; //输出数组名和元素值 System.out.println(arr); System.out.println(arr[0]); System.out.println(arr[1]); System.out.println("----"); System.out.println(arr2); System.out.println(arr2[0]); System.out.println(arr2[1]); System.out.println(arr2[2]); &#125;&#125; 数组操作的常见问题数组索引越界ArrayIndexOutOfBoundsException访问到了数组中的不存在的索引时发生。空指针异常NullPointerException数组引用没有指向实体，却在操作实体中的元素时 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/* 数组遍历：就是依次输出数组中的每一个元素。 注意：数组提供了一个属性length，用于获取数组的长度。 格式：数组名.length*/class ArrayTest &#123; public static void main(String[] args) &#123; //定义数组 int[] arr = &#123;11,22,33,44,55&#125;; //获取每一个元素 //如何获取呢?我们知道数组名结合编号(索引)就可以找到数据 System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); System.out.println(arr[3]); System.out.println(arr[4]); System.out.println("--------------------"); //虽然这种做法可以，但是不是我想要的 //我们发现，代码的重复度很高 //输出语句，数组名都是相同的，仅仅是索引是变化的 //我们就可以使用循环搞定索引值 for(int x=0; x&lt;5; x++) &#123; //x=0,1,2,3,4 System.out.println(arr[x]); &#125; System.out.println("--------------------"); //从0开始我们是明确的，但是为什么到5呢，我们是数了一下数组的个数 //继续看下个数组如何遍历 int[] arr2 = &#123;1,2,3,4,5,6,7,8,9,10,11,2,2,3,4,5,7,8,5,3,5,6,8,7,8,5,3,5,6,8,7,8,5,3,5,6,8,7,8,5,3,5,6,8,7,8,5,3,5,6,8&#125;; //而我们在很多时候，数组的元素不能靠数 //这个时候，数组就给我们提供了一个属性：length专门用于获取数组的长度 //格式：数组名.length 返回数组的长度 System.out.println(arr.length); System.out.println(arr2.length); System.out.println("--------------------"); //改进第一个程序 for(int x=0; x&lt;arr.length; x++) &#123; System.out.println(arr[x]); &#125; System.out.println("--------------------"); //我们如果想要对多个数组进行遍历，每个数组的遍历我们都把代码写一遍，麻烦不 //麻烦，所以，我们准备用方法改进。 //用方法改进后，请调用 printArray(arr); System.out.println("--------------------"); printArray(arr2); System.out.println("--------------------"); printArray2(arr); &#125; /* 遍历数组的方法 两个明确： 返回值类型：void 参数列表：int[] arr */ public static void printArray(int[] arr) &#123; for(int x=0; x&lt;arr.length; x++) &#123; System.out.println(arr[x]); &#125; &#125; //请看改进版本 public static void printArray2(int[] arr) &#123; System.out.print("["); for(int x=0; x&lt;arr.length; x++) &#123; if(x == arr.length-1) &#123; //这是最后一个元素 System.out.println(arr[x]+"]"); &#125;else &#123; System.out.print(arr[x]+", "); &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/* 数组获取最值(获取数组中的最大值最小值) 分析： A:定义一个数组，并对数组的元素进行静态初始化。 B:从数组中任意的找一个元素作为参照物(一般取第一个),默认它就是最大值。 C:然后遍历其他的元素，依次获取和参照物进行比较，如果大就留下来，如果小，就离开。 D:最后参照物里面保存的就是最大值。*/class ArrayTest2 &#123; public static void main(String[] args) &#123; //定义一个数组 int[] arr = &#123;34,98,10,25,67&#125;; //请获取数组中的最大值 /* //从数组中任意的找一个元素作为参照物 int max = arr[0]; //然后遍历其他的元素 for(int x=1; x&lt;arr.length; x++) &#123; //依次获取和参照物进行比较，如果大就留下来，如果小，就离开。 if(arr[x] &gt; max) &#123; max = arr[x]; &#125; &#125; //最后参照物里面保存的就是最大值。 System.out.println("max:"+max); */ //把这个代码用方法改进 //调用方法 int max = getMax(arr); System.out.println("max:"+max); //请获取数组中的最小值 int min = getMin(arr); System.out.println("min:"+min); &#125; /* 需求：获取数组中的最大值 两个明确： 返回值类型：int 参数列表：int[] arr */ public static int getMax(int[] arr) &#123; //从数组中任意的找一个元素作为参照物 int max = arr[0]; //然后遍历其他的元素 for(int x=1; x&lt;arr.length; x++) &#123; //依次获取和参照物进行比较，如果大就留下来，如果小，就离开。 if(arr[x] &gt; max) &#123; max = arr[x]; &#125; &#125; //最后参照物里面保存的就是最大值。 return max; &#125; public static int getMin(int[] arr) &#123; //从数组中任意的找一个元素作为参照物 int min = arr[0]; //然后遍历其他的元素 for(int x=1; x&lt;arr.length; x++) &#123; //依次获取和参照物进行比较，如果小就留下来，如果大，就离开。 if(arr[x] &lt; min) &#123; min = arr[x]; &#125; &#125; //最后参照物里面保存的就是最小值。 return min; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/* 数组元素逆序 (就是把元素对调) 分析： A:定义一个数组，并进行静态初始化。 B:思路 把0索引和arr.length-1的数据交换 把1索引和arr.length-2的数据交换 ... 只要做到arr.length/2的时候即可。*/class ArrayTest3 &#123; public static void main(String[] args) &#123; //定义一个数组，并进行静态初始化。 int[] arr = &#123;12,98,50,34,76&#125;; //逆序前 System.out.println("逆序前："); printArray(arr); //逆序后 System.out.println("逆序后："); //reverse(arr); reverse2(arr); printArray(arr); &#125; /* 需求：数组逆序 两个明确： 返回值类型：void (有人会想到应该返回的是逆序后的数组，但是没必要，因为这两个数组其实是同一个数组) 参数列表：int[] arr */ public static void reverse(int[] arr) &#123; /* //第一次交换 int temp = arr[0]; arr[0] = arr[arr.length-1-0]; arr[arr.length-1-0] = temp; //第二次交换 int temp = arr[1]; arr[1] = arr[arr.length-1-1]; arr[arr.length-1-1] = temp; //第三次交换 int temp = arr[2]; arr[2] = arr[arr.length-1-2]; arr[arr.length-1-2] = temp; */ //用循环改进 for(int x=0; x&lt;arr.length/2; x++) &#123; int temp = arr[x]; arr[x] = arr[arr.length-1-x]; arr[arr.length-1-x] = temp; &#125; &#125; public static void reverse2(int[] arr) &#123; for(int start=0,end=arr.length-1; start&lt;=end; start++,end--) &#123; int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; &#125; &#125; //遍历数组 public static void printArray(int[] arr) &#123; System.out.print("["); for(int x=0; x&lt;arr.length; x++) &#123; if(x == arr.length-1) &#123; //这是最后一个元素 System.out.println(arr[x]+"]"); &#125;else &#123; System.out.print(arr[x]+", "); &#125; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[这是我的学习小站，我会更新学习情况以及日常]]></title>
      <url>%2F2016%2F11%2F29%2FHello%20World%2F</url>
      <content type="text"></content>
    </entry>

    
  
  
</search>
